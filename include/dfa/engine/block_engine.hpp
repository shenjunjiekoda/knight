//===- block_engine.hpp -----------------------------------------------===//
//
// Copyright (c) 2024 Junjie Shen
//
// see https://github.com/shenjunjiekoda/knight/blob/main/LICENSE for
// license information.
//
//===------------------------------------------------------------------===//
//
//  This header defines the execution engine for the Basic Block.
//
//===------------------------------------------------------------------===//

#pragma once

#include "dfa/analysis_manager.hpp"
#include "dfa/location_context.hpp"
#include "dfa/location_manager.hpp"
#include "dfa/proc_cfg.hpp"
#include "dfa/program_state.hpp"
#include "dfa/stack_frame.hpp"
#include "dfa/symbol_manager.hpp"

#include <clang/AST/DeclCXX.h>
#include <clang/AST/ExprCXX.h>

namespace knight::dfa {

class BlockExecutionEngine {
  public:
    using GraphRef = typename ProcCFG::GraphRef;
    using NodeRef = typename ProcCFG::NodeRef;
    using FunctionRef = typename ProcCFG::FunctionRef;
    using StmtRef = ProcCFG::StmtRef;
    using DeclRef = ProcCFG::DeclRef;
    using VarDeclRef = ProcCFG::VarDeclRef;
    using StmtResultCache = std::unordered_map< StmtRef, ProgramStateRef >;

  private:
    GraphRef m_cfg;
    NodeRef m_node;
    AnalysisManager& m_analysis_manager;
    SymbolManager& m_sym_manager;
    LocationManager& m_location_manager;

    ProgramStateRef m_state;
    StmtResultCache& m_stmt_pre;
    StmtResultCache& m_stmt_post;
    const StackFrame* m_frame;

    int m_current_elem_idx = -1;

  public:
    BlockExecutionEngine(GraphRef cfg,
                         NodeRef node,
                         AnalysisManager& analysis_manager,
                         SymbolManager& symbol_manager,
                         LocationManager& location_manager,
                         ProgramStateRef in_state,
                         StmtResultCache& stmt_pre,
                         StmtResultCache& stmt_post,
                         const StackFrame* frame)
        : m_cfg(cfg),
          m_node(node),
          m_analysis_manager(analysis_manager),
          m_sym_manager(symbol_manager),
          m_location_manager(location_manager),
          m_state(std::move(in_state)),
          m_stmt_pre(stmt_pre),
          m_stmt_post(stmt_post),
          m_frame(frame) {}

  public:
    /// \brief General transformer for all nodes.
    void exec();

    [[nodiscard]] ProgramStateRef get_state() const { return m_state; }

  private:
    [[nodiscard]] const LocationContext* get_location_context() const;

    /// \brief Transfer C++ base or member initializer from constructor's
    /// initialization list.
    void exec_cxx_ctor_initializer(clang::CXXCtorInitializer* initializer);

    /// \brief Transfer beginning of a scope implicitly generated
    /// by the compiler on encountering a CompoundStmt
    ///
    /// \param trigger_stmt The CompoundStmt that triggers the scope
    /// begin transfer.
    /// \param var_decl The variable declaration that triggers the scope
    /// begin transfer.
    void exec_scope_begin(StmtRef trigger_stmt, VarDeclRef var_decl);

    /// \brief Transfer ending of a scope implicitly generated by
    /// the compiler after the last Stmt in a CompoundStmt's body
    void exec_scope_end(StmtRef trigger_stmt, VarDeclRef var_decl);

    /// \brief Transfer C++ new allocator call
    void exec_new_allocator_call(const clang::CXXNewExpr* expr);

    /// \brief Transfer the point where the lifetime of an automatic object ends
    void exec_lifetime_ends(StmtRef trigger_stmt, VarDeclRef var_decl);

    /// \brief Transfer the stmt
    ProgramStateRef exec_cfg_stmt(StmtRef stmt, const ProgramStateRef& state);

}; // class BlockExecutionEngine

} // namespace knight::dfa